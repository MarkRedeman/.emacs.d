;;; ofc-semantic-php.wy -- LALR grammar for PHP 5.5

%package ofc-semantic-php-wy
%provide ofc-semantic-php-wy

%languagemode php-mode

;; The default start symbol
%start grammar

%start compilation_units
%start compilation_unit
%start include_declaration
%start require_expr
%start type_declaration
%start class_declaration
%start class_body
%start class_member_declaration
%start interface_declaration
%start interface_body
%start interface_member_declaration
%start method_declaration
%start method_declarator
%start identifier_list
%start method_body
%start block
%start formal_parameter_list
%start formal_parameters
%start formal_parameter
%start field_declaration
%start variable_declarators
%start variable_declarator
%start variable_declarator_id
%start variable_initializer
%start class_modifiers
%start class_modifier
%start method_modifiers
%start method_modifier
%start field_modifiers
%start field_modifier

;; Keyword
%type    <keyword>
%keyword T_EXIT            "exit"
%keyword T_EXIT            "die"
%keyword T_FUNCTION        "function"
%keyword T_CONST           "const"
%put     T_CONST summary
"Unused reserved word"
%keyword T_RETURN          "return"
%put     T_RETURN summary
"return [<expr>] ;"
%keyword T_TRY             "try"
%put     T_TRY summary
"try {<stmts>} [catch(<parm>) {<stmts>} ...] [finally {<stmts>}]"
%keyword T_CATCH           "catch"
%put     T_CATCH summary
"try {<stmts>} catch(<parm>) {<stmts>} ... "
%keyword T_THROW           "throw"
%keyword T_IF              "if"
%put     T_IF summary
"if (<expr>) <stmt> [else <stmt>]"
%keyword T_ELSEIF          "elseif"
%keyword T_ENDIF           "endif"
%keyword T_ELSE            "else"
%put     T_ELSE summary
"if (<expr>) <stmt> else <stmt>"
%keyword T_WHILE           "while"
%put     T_WHILE summary
"while (<expr>) <stmt> | do <stmt> while (<expr>);"
%keyword T_ENDWHILE        "endwhile"
%keyword T_DO              "do"
%put     T_DO summary
"do <stmt> while (<expr>);"
%keyword T_FOR             "for"
%put     T_FOR summary
"for ([<init-expr>]; [<expr>]; [<update-expr>]) <stmt>"
%keyword T_ENDFOR          "endfor"
%keyword T_FOREACH         "foreach"
%keyword T_ENDFOREACH      "endforeach"
%keyword T_DECLARE         "declare"
%keyword T_ENDDECLARE      "enddeclare"
%keyword T_INSTANCEOF      "instanceof"
%keyword INT          "int"
%put     T_INT summary
%keyword T_AS              "as"
%keyword T_SWITCH          "switch"
%keyword T_ENDSWITCH       "endswitch"
%keyword T_CASE            "case"
%put     T_CASE summary
"switch(<expr>) {case <const-expr>: <stmts> ... }"
%keyword T_DEFAULT         "default"
%put     T_DEFAULT summary
"switch(<expr>) { ... default: <stmts>}"
%keyword T_BREAK           "break"
%put     T_BREAK summary
"break [<label>] ;"
%keyword T_CONTINUE        "continue"
%put     T_CONTINUE summary
"continue [<label>] ;"
%keyword T_ECHO            "echo"
%keyword T_PRINT           "print"
%keyword T_CLASS           "class"
%put     T_CLASS summary
"Class declaration: class <name>"
%keyword T_INTERFACE       "interface"
%put     T_INTERFACE summary
"Interface declaration: interface <name>"
%keyword T_EXTENDS         "extends"
%put     T_EXTENDS summary
"SuperClass|SuperInterfaces declaration: extends <name> [, ...]"
%keyword T_IMPLEMENTS      "implements"
%put     T_IMPLEMENTS summary
"Class SuperInterfaces declaration: implements <name> [, ...]"
%keyword T_NEW             "new"
%keyword PACKAGE      "package"
%put     T_PACKAGE summary
%keyword T_CLONE           "clone"
%keyword T_VAR             "var"
%keyword T_EVAL            "eval"
%keyword T_INCLUDE         "include"
%keyword T_INCLUDE_ONCE    "include_once"
%keyword T_REQUIRE         "require"
%keyword T_REQUIRE_ONCE    "require_once"
%keyword T_GLOBAL          "global"
%keyword T_ISSET           "isset"
%keyword T_EMPTY           "empty"
%keyword T_HALT_COMPILER   "__halt_compiler"
%keyword T_STATIC          "static"
%put     T_STATIC summary
"Declaration modifier: static {class|interface|<type>} <name> ..."
%keyword T_ABSTRACT        "abstract"
%put     T_ABSTRACT summary
"Class|Method declaration modifier: abstract {class|<type>} <name> ..."
%keyword T_FINAL           "final"
%put     T_FINAL summary
"Class|Member declaration modifier: final {class|<type>} <name> ..."
%keyword T_PRIVATE         "private"
%put     T_PRIVATE summary
"Access level modifier: private {class|interface|<type>} <name> ..."
%keyword T_PROTECTED       "protected"
%put     T_PROTECTED summary
"Access level modifier: protected {class|interface|<type>} <name> ..."
%keyword T_PUBLIC          "public"
%put     T_PUBLIC summary
"Access level modifier: public {class|interface|<type>} <name> ..."
%keyword T_UNSET           "unset"
%keyword T_LIST            "list"
%keyword T_ARRAY           "array"
%keyword T_LOGICAL_OR      "or"
%keyword T_LOGICAL_AND     "and"
%keyword T_LOGICAL_XOR     "xor"
%keyword T_CLASS_C         "__CLASS__"
%keyword T_FUNC_C          "__FUNCTION__"
%keyword T_METHOD_C        "__METHOD__"
%keyword T_LINE            "__LINE__"
%keyword T_FILE            "__FILE__"

;; Literals
%type  <symbol>  ;;syntax "\\(\\$?[a-zA-Z_][a-zA-Z0-9_]+\\)"
%token <symbol>  T_STRING

%type  <string>
%token <string>  T_CONSTANT_ENCAPSED_STRING

%type  <number>
%token <number>  T_NUMBER

;; Don't generate these analyzers which needs special handling code.
%token <code>    PROLOGUE
%token <code>    EPILOGUE

;; Blocks & Parenthesis
%type  <block>
%token <block>  PAREN_BLOCK "(PAREN_OPEN PAREN_CLOSE)"
%token <block>  BRACE_BLOCK "(BRACE_OPEN BRACE_CLOSE)"
%token <block>  BRACK_BLOCK "(BRACK_OPEN BRACK_CLOSE)"

%token <open-paren>   PAREN_OPEN  "("
%token <close-paren>  PAREN_CLOSE ")"
%token <open-paren>   BRACE_OPEN  "{"
%token <close-paren>  BRACE_CLOSE "}"
%token <open-paren>   BRACK_OPEN  "["
%token <close-paren>  BRACK_CLOSE "]"

;; Punctuations
%type  <punctuation>
%token <punctuation> T_OBJECT_OPERATOR      "->"
%token <punctuation> T_SEMICOLON            ";"
%token <punctuation> T_PAAMAYIM_NEKUDOTAYIM "::"
%token <punctuation> T_INC                  "++"
%token <punctuation> T_DEC                  "--"
%token <punctuation> T_IS_IDENTICAL         "==="
%token <punctuation> T_IS_NOT_IDENTICAL     "!=="
%token <punctuation> T_IS_EQUAL             "=="
%token <punctuation> T_IS_NOT_EQUAL         "!="
%token <punctuation> T_IS_NOT_EQUAL         "<>"
%token <punctuation> T_IS_SMALLER_OR_EQUAL  "<="
%token <punctuation> T_IS_GREATER_OR_EQUAL  ">="
%token <punctuation> T_PLUS_EQUAL           "+="
%token <punctuation> T_MINUS_EQUAL          "-="
%token <punctuation> T_MUL_EQUAL            "*="
%token <punctuation> T_DIV_EQUAL            "/="
%token <punctuation> T_CONCAT_EQUAL         ".="
%token <punctuation> T_MOD_EQUAL            "%="
%token <punctuation> T_SL_EQUAL             "<<="
%token <punctuation> T_SR_EQUAL             ">>="
%token <punctuation> T_AND_EQUAL            "&="
%token <punctuation> T_OR_EQUAL             "|="
%token <punctuation> T_XOR_EQUAL            "^="
%token <punctuation> T_BOOLEAN_OR           "||"
%token <punctuation> T_BOOLEAN_AND          "&&"
%token <punctuation> T_SL                   "<<"
%token <punctuation> T_SR                   ">>"
%token <punctuation> T_DOUBLE_ARROW         "=>"
%token <punctuation> T_HEREDOC              "<<<"
%token <punctuation> T_NOT         	    "!"
%token <punctuation> T_MOD         	    "%"
%token <punctuation> T_AND         	    "&"
%token <punctuation> T_MULT        	    "*"
%token <punctuation> T_PLUS        	    "+"
%token <punctuation> T_COMMA       	    ","
%token <punctuation> T_MINUS       	    "-"
%token <punctuation> T_DOT         	    "."
%token <punctuation> T_DIV         	    "/"
%token <punctuation> T_COLON       	    ":"
%token <punctuation> T_SEMI	   	    ";"
%token <punctuation> T_LT          	    "<"
%token <punctuation> T_EQ          	    "="
%token <punctuation> T_GT          	    ">"
%token <punctuation> T_URSHIFT     	    ">>>"
%token <punctuation> T_URSHIFTEQ   	    ">>>="
%token <punctuation> T_QUESTION    	    "?"
%token <punctuation> T_XOR         	    "^"
%token <punctuation> T_OR          	    "|"
%token <punctuation> T_COMP        	    "~"
%token <punctuation> T_ASTERISK        	    "@"
%token <punctuation> T_DOLLER               "$"

;; Precedence definitions
%left T_INCLUDE T_INCLUDE_ONCE T_EVAL T_REQUIRE T_REQUIRE_ONCE
%left T_COMMA
%left T_LOGICAL_OR
%left T_LOGICAL_XOR
%left T_LOGICAL_AND
%right T_PRINT
%left T_EQ T_PLUS_EQUAL T_MINUS_EQUAL T_MUL_EQUAL T_DIV_EQUAL T_CONCAT_EQUAL T_MOD_EQUAL T_AND_EQUAL T_OR_EQUAL T_XOR_EQUAL T_SL_EQUAL T_SR_EQUAL
%left T_QUESTION T_COLON
%left T_BOOLEAN_OR
%left T_BOOLEAN_AND
%left T_OR
%left T_XOR
%left T_AND
%nonassoc T_IS_EQUAL T_IS_NOT_EQUAL T_IS_IDENTICAL T_IS_NOT_IDENTICAL
%nonassoc T_LT T_IS_SMALLER_OR_EQUAL '>' T_IS_GREATER_OR_EQUAL
%left T_SL T_SR
%left T_PLUS T_MINUS T_DOT
%left T_MULT T_DIV T_MOD
%right T_NOT
%nonassoc T_INSTANCEOF
%right T_COMP T_INC T_DEC T_INT_CAST T_DOUBLE_CAST T_STRING_CAST T_ARRAY_CAST T_OBJECT_CAST T_BOOL_CAST T_UNSET_CAST T_ASTERISK
%right BRACK_CLOSE
%nonassoc T_NEW T_CLONE
%token T_EXIT
%token T_IF
%left T_ELSEIF
%left T_ELSE
%left T_ENDIF

%%

grammar
  : PROLOGUE compilation_units EPILOGUE
    (identity $2)
  | PROLOGUE compilation_units
    (identity $2)
  ;

compilation_units
  : ;;EMPTY
  | compilation_unit compilation_units
    (if $2 (append $2 (EXPANDTAG $1)) (EXPANDTAG $1))
  ;

compilation_unit
  : include_declaration
  | type_declaration
  ;

include_declaration
  : require_expr T_SEMICOLON
    (identity $2)
  | T_REQUIRE require_expr T_SEMICOLON
    (identity $2)
  | T_REQUIRE_ONCE require_expr T_SEMICOLON
    (identity $2)
  | T_INCLUDE require_expr T_SEMICOLON
    (identity $2)
  | T_INCLUDE_ONCE require_expr T_SEMICOLON
    (identity $2)
  ;

require_expr
  : T_CONSTANT_ENCAPSED_STRING
    (INCLUDE-TAG $1 nil)
  | PAREN_BLOCK
    (INCLUDE-TAG $1 nil)
  ;

type_declaration
  : function_declaration
  | class_declaration
  | interface_declaration
  ;

;;; Type Declaration token
;; ("NAME" type "TYPE" ( PART-LIST ) ( PARENTS ) EXTRA-SPEC "DOCSTRING")
class_declaration
  : class_modifiers_opt T_CLASS T_STRING superc_opt interfaces_opt class_body
    (TYPE-TAG $3 $2 $6 (if (or $4 $5) (cons $4 $5)) :typemodifiers $1)
  ;

superc_opt
  : ;;EMPTY
  | T_EXTENDS T_STRING
    (identity $2)
  ;

interfaces_opt
  : ;;EMPTY
  | T_IMPLEMENTS identifier_list
    (nreverse $2)
  ;

class_body
  : BRACE_BLOCK
    (EXPANDFULL $1 class_member_declaration)
  ;

class_member_declaration
  : BRACE_OPEN
    ()
  | BRACE_CLOSE
    ()
  | block
    ()
  | interface_declaration
  | class_declaration
  | method_declaration
  | field_declaration
  ;

;;; Type Declaration token
;; ("NAME" type "TYPE" ( PART-LIST ) ( PARENTS ) EXTRA-SPEC "DOCSTRING")
interface_declaration
  : class_modifiers_opt T_INTERFACE T_STRING extends_interfaces_opt interface_body
    (TYPE-TAG $3 $2 $5 (if $4 (cons nil $4)) :typemodifiers $1)
  ;

extends_interfaces_opt
  : ;;EMPTY
  | T_EXTENDS identifier_list
    (identity $2)
  ;

interface_body
  : BRACE_BLOCK
    (EXPANDFULL $1 interface_member_declaration)
  ;

interface_member_declaration
  : BRACE_OPEN
    ()
  | BRACE_CLOSE
    ()
  | interface_declaration
  | class_declaration
  | method_declaration
  | field_declaration
  ;

function_declaration
  :  method_declarator method_body
    (FUNCTION-TAG (car $1) nil (cdr $1))
  ;

;;; Function token
;; ("NAME" function "TYPE" ( ARG-LIST ) EXTRA-SPEC "DOCSTRING")
method_declaration
  : method_modifiers_opt method_declarator method_body
    (FUNCTION-TAG (car $2) nil (cdr $2) :typemodifiers $1)
  ;

method_declarator
  : T_FUNCTION reference_opt T_STRING formal_parameter_list
    (cons $3 $4)
  ;

identifier_list
  : identifier_list T_COMMA T_STRING
    (cons $3 $1)
  | T_STRING
    (list $1)
  ;

method_body
  : T_SEMICOLON
  | block
  ;

;; Just eat {...} block!
block
  : BRACE_BLOCK
  ;

formal_parameter_list
  : PAREN_BLOCK
    (EXPANDFULL $1 formal_parameters)
  ;

formal_parameters
  : PAREN_OPEN
    ()
  | PAREN_CLOSE
    ()
  | formal_parameter T_COMMA
  | formal_parameter PAREN_CLOSE
  ;

;;; Variable token
;; ("NAME" variable "TYPE" DEFAULT-VALUE EXTRA-SPEC "DOCSTRING")
formal_parameter
  : variable_declarator_id T_EQ expression
    (VARIABLE-TAG $1 nil $region3)
  | variable_declarator_id
    (VARIABLE-TAG $1 nil nil)
  ;

;;; Variable token
;; ("NAME" variable "TYPE" DEFAULT-VALUE EXTRA-SPEC "DOCSTRING")
field_declaration
  : field_modifiers_opt variable_declarators T_SEMICOLON
    (VARIABLE-TAG $2 nil nil :typemodifiers $1)
  ;

variable_declarators
  : variable_declarators T_COMMA variable_declarator
    (cons $3 $1)
  | variable_declarator
    (list $1)
  ;

variable_declarator
  : variable_declarator_id T_EQ variable_initializer
    (list $1 nil nil $3)
  | variable_declarator_id
    (list $1)
  ;

variable_declarator_id
  : reference_opt T_STRING dims_opt
    (concat $2 $3)
  ;

reference_opt
  : ;;EMPTY
  | T_AND
  ;

variable_initializer
  : expression
  ;

;; Just eat expression!
expression
  : expression term
  | term
  ;

term
  : literal
  | operator
  | T_STRING
  | BRACK_BLOCK
  | PAREN_BLOCK
  | BRACE_BLOCK
  | T_NEW
  | T_CLONE
  | T_ARRAY
  ;

literal
;;   : NULL_LITERAL
;;   | BOOLEAN_LITERAL
  : T_CONSTANT_ENCAPSED_STRING
  | T_NUMBER
  ;

operator
  : T_OBJECT_OPERATOR
  | T_PAAMAYIM_NEKUDOTAYIM
  | T_INC
  | T_DEC
  | T_IS_IDENTICAL
  | T_IS_NOT_IDENTICAL
  | T_IS_EQUAL
  | T_IS_NOT_EQUAL
  | T_IS_NOT_EQUAL
  | T_IS_SMALLER_OR_EQUAL
  | T_IS_GREATER_OR_EQUAL
  | T_PLUS_EQUAL
  | T_MINUS_EQUAL
  | T_MUL_EQUAL
  | T_DIV_EQUAL
  | T_CONCAT_EQUAL
  | T_MOD_EQUAL
  | T_SL_EQUAL
  | T_SR_EQUAL
  | T_AND_EQUAL
  | T_OR_EQUAL
  | T_XOR_EQUAL
  | T_BOOLEAN_OR
  | T_BOOLEAN_AND
  | T_SL
  | T_SR
  | T_DOUBLE_ARROW
  | T_HEREDOC
  | T_NOT
  | T_MOD
  | T_AND
  | T_MULT
  | T_PLUS
  | T_COMMA
  | T_MINUS
  | T_DOT
  | T_DIV
  | T_COLON
  | T_LT
  | T_EQ
  | T_GT
  | T_URSHIFT
  | T_URSHIFTEQ
  | T_QUESTION
  | T_XOR
  | T_OR
  | T_COMP
  | T_ASTERISK
  | T_LIST
  | T_ARRAY
  | T_LOGICAL_OR
  | T_LOGICAL_AND
  | T_LOGICAL_XOR
  ;

class_modifiers_opt
  : ;;EMPTY
  | class_modifiers
    (nreverse $1)
  ;

class_modifiers
  : class_modifiers class_modifier
    (cons $2 $1)
  | class_modifier
    (list $1)
  ;

class_modifier
  : T_FINAL
  | T_ABSTRACT
  ;

method_modifiers_opt
  : ;;EMPTY
  | method_modifiers
    (nreverse $1)
  ;

method_modifiers
  : method_modifiers method_modifier
    (cons $2 $1)
  | method_modifier
    (list $1)
  ;

method_modifier
  : T_FINAL
  | T_ABSTRACT
  | T_STATIC
  | T_PRIVATE
  | T_PROTECTED
  | T_PUBLIC
  ;

field_modifiers_opt
  : ;;EMPTY
  | field_modifiers
    (nreverse $1)
  ;

field_modifiers
  : field_modifiers field_modifier
    (cons $2 $1)
  | field_modifier
    (list $1)
  ;

field_modifier
  : method_modifier
  | T_VAR
  ;

dims_opt
  : ;;EMPTY
    (identity "")
  | dims
  ;

dims
  : dims BRACK_BLOCK
    (concat $1 "[]")
  | BRACK_BLOCK
    (identity "[]")
  ;

;;; ofc-semantic-php.wy ends here
